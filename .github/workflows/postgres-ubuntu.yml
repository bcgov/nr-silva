name: Postgres Ubuntu PostGIS Deploy

on:
  workflow_dispatch:
    inputs:
      tag:
        description: Container tag to build/push (defaults to run id)
        required: false
        type: string

permissions:
  packages: write

jobs:
  build-and-deploy:
    name: Build and Deploy Ubuntu PostGIS
    runs-on: ubuntu-24.04
    environment: test
    env:
      OC_NAMESPACE: ${{ vars.OC_NAMESPACE }}
      OC_SERVER: ${{ vars.OC_SERVER }}
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Set variables
        id: vars
        run: |
          TAG="${{ inputs.tag }}"
          if [ -z "$TAG" ]; then TAG="${{ github.run_id }}"; fi
          # Use the environment's OC_NAMESPACE secret. This workflow MUST run with the 'test' environment
          # configured; fail early if the environment secret is missing so we don't accidentally deploy elsewhere.
          OC_NAMESPACE="${{ vars.OC_NAMESPACE }}"
          if [ -z "$OC_NAMESPACE" ]; then
            echo "::error::OC_NAMESPACE is not set in environment secrets. This workflow must run in the 'test' environment with OC_NAMESPACE configured."
            exit 1
          fi
          # OC_SERVER is optional but prefer the environment secret if present
          OC_SERVER="${{ vars.OC_SERVER }}"
          if [ -z "$OC_SERVER" ]; then
            echo "::warning::OC_SERVER not set in environment secrets; proceeding but deployer may require OC_SERVER depending on configuration."
          fi
          echo "tag=$TAG" >> $GITHUB_OUTPUT
          echo "OC_NAMESPACE=$OC_NAMESPACE" >> $GITHUB_OUTPUT
          echo "OC_SERVER=$OC_SERVER" >> $GITHUB_OUTPUT

      - name: Log in to GHCR
        uses: docker/login-action@v3
        with:
          registry: ghcr.io
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Install OpenShift CLI (oc)
        run: |
          set -euo pipefail
          echo "Installing OpenShift 'oc' CLI..."
          tmpdir=$(mktemp -d)
          cd "$tmpdir"
          # download the stable client tarball from the official mirror
          curl -fsSL -o openshift-client.tar.gz https://mirror.openshift.com/pub/openshift-v4/clients/ocp/stable/openshift-client-linux.tar.gz
          tar -xzf openshift-client.tar.gz
          sudo mv oc /usr/local/bin/oc
          sudo chmod +x /usr/local/bin/oc
          echo "oc version:"; oc version --client
          cd -
          rm -rf "$tmpdir"

      - name: Build and push image (postgres-oracle)
        id: build
        uses: docker/build-push-action@v6
        with:
          context: ./postgres-oracle
          file: ./postgres-oracle/Dockerfile
          push: true
          platforms: linux/amd64
          tags: |
            ghcr.io/${{ github.repository }}/ubuntu-postgis:${{ steps.vars.outputs.tag }}

      - name: Login to OpenShift
        run: |
          set -euo pipefail
          oc login --token="${{ secrets.OC_TOKEN }}" --server="${{ vars.OC_SERVER }}"
          oc project "${{ vars.OC_NAMESPACE }}"

      - name: Purge existing deployment and PVC on re-run
        if: ${{ github.run_attempt > 1 }}
        run: |
          echo "Rerun detected (attempt ${{ github.run_attempt }}). Purging Deployment, Service, Secret and PVC to reset data..."
          oc delete deployment ubuntu-postgis --ignore-not-found
          oc delete svc ubuntu-postgis-svc --ignore-not-found
          oc delete secret ubuntu-postgis-secret --ignore-not-found
          oc delete pvc ubuntu-postgis-pvc --ignore-not-found
          # Wait for pods to fully terminate to avoid PVC race conditions
          oc wait --for=delete pod -l app=ubuntu-postgis --timeout=120s 2>/dev/null || true
          echo "Purge complete."

      - name: Render secret manifest from GitHub Secrets
        id: render-secret
        run: |
          set -euo pipefail
          umask 077
          tmpfile="$GITHUB_WORKSPACE/ubuntu-postgis-secret.yml"
          printf '%s\n' \
            'apiVersion: v1' \
            'kind: Secret' \
            'metadata:' \
            '  name: ubuntu-postgis-secret' \
            'type: Opaque' \
            'stringData:' \
            '  POSTGRES_USER: "postgres"' \
            "  POSTGRES_PASSWORD: \"${{ secrets.UBUNTU_POSTGRES }}\"" \
            '  POSTGRES_DB: "postgres"' \
            > "$tmpfile"
          chmod 600 "$tmpfile"
          echo "secret_file=$tmpfile" >> $GITHUB_OUTPUT

      - name: Apply Secret (oc apply)
        run: |
          set -euo pipefail
          oc apply -f "${{ steps.render-secret.outputs.secret_file }}"

      - name: Render deployment with built image
        id: render
        run: |
          # Prefer immutable digest if build produced one, fall back to tag
          if [ -n "${{ steps.build.outputs.digest }}" ]; then
            IMAGE="ghcr.io/${{ github.repository }}/ubuntu-postgis@${{ steps.build.outputs.digest }}"
          else
            IMAGE="ghcr.io/${{ github.repository }}/ubuntu-postgis:${{ steps.vars.outputs.tag }}"
          fi
          echo "Using image: $IMAGE"
          # Replace placeholder in the plain Kubernetes manifest (produce absolute path)
          RENDERED_FILE="$GITHUB_WORKSPACE/rendered-ubuntu-postgis-deploy.yml"
          cp postgres-oracle/ubuntu-postgis-deploy.yml "$RENDERED_FILE"
          sed -i "s|IMAGE_PLACEHOLDER|$IMAGE|g" "$RENDERED_FILE"
          ls -l "$RENDERED_FILE"
          echo "rendered_file=$RENDERED_FILE" >> $GITHUB_OUTPUT

      - name: Deploy resources (oc apply)
        run: |
          set -euo pipefail
          oc apply -f "${{ steps.render.outputs.rendered_file }}"
          echo "Deployment applied. Waiting for rollout..."

      - name: Cleanup secret file
        if: always()
        run: |
          set +x
          tmp="${{ steps.render-secret.outputs.secret_file }}"
          if [ -n "$tmp" ] && [ -f "$tmp" ]; then
            shred -u "$tmp" || rm -f "$tmp"
          fi
          set -x
