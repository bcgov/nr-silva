name: Postgres Ubuntu PostGIS Deploy

on:
  workflow_dispatch:
    inputs:
      tag:
        description: Container tag to build/push (defaults to run id)
        required: false
        type: string

permissions:
  packages: write

jobs:
  build-and-deploy:
    name: Build and Deploy Ubuntu PostGIS
    runs-on: ubuntu-24.04
    environment: test
    env:
      OC_NAMESPACE: ${{ vars.OC_NAMESPACE }}
      OC_SERVER: ${{ vars.OC_SERVER }}
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Set variables
        id: vars
        run: |
          TAG="${{ inputs.tag }}"
          if [ -z "$TAG" ]; then TAG="${{ github.run_id }}"; fi
          # Use the environment's OC_NAMESPACE secret. This workflow MUST run with the 'test' environment
          # configured; fail early if the environment secret is missing so we don't accidentally deploy elsewhere.
          OC_NAMESPACE="${{ vars.OC_NAMESPACE }}"
          if [ -z "$OC_NAMESPACE" ]; then
            echo "::error::OC_NAMESPACE is not set in environment secrets. This workflow must run in the 'test' environment with OC_NAMESPACE configured."
            exit 1
          fi
          # OC_SERVER is optional but prefer the environment secret if present
          OC_SERVER="${{ vars.OC_SERVER }}"
          if [ -z "$OC_SERVER" ]; then
            echo "::warning::OC_SERVER not set in environment secrets; proceeding but deployer may require OC_SERVER depending on configuration."
          fi
          echo "tag=$TAG" >> $GITHUB_OUTPUT
          echo "OC_NAMESPACE=$OC_NAMESPACE" >> $GITHUB_OUTPUT
          echo "OC_SERVER=$OC_SERVER" >> $GITHUB_OUTPUT

      - name: Log in to GHCR
        uses: docker/login-action@v3
        with:
          registry: ghcr.io
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Install OpenShift CLI (oc)
        run: |
          set -euo pipefail
          echo "Installing OpenShift 'oc' CLI..."
          tmpdir=$(mktemp -d)
          cd "$tmpdir"
          # download the stable client tarball from the official mirror
          curl -fsSL -o openshift-client.tar.gz https://mirror.openshift.com/pub/openshift-v4/clients/ocp/stable/openshift-client-linux.tar.gz
          tar -xzf openshift-client.tar.gz
          sudo mv oc /usr/local/bin/oc
          sudo chmod +x /usr/local/bin/oc
          echo "oc version:"; oc version --client
          cd -
          rm -rf "$tmpdir"

      - name: Build and push image (postgres-oracle)
        id: build
        uses: docker/build-push-action@v6
        with:
          context: ./postgres-oracle
          file: ./postgres-oracle/Dockerfile
          push: true
          platforms: linux/amd64
          tags: |
            ghcr.io/${{ github.repository }}/ubuntu-postgis:${{ steps.vars.outputs.tag }}

      - name: Render secret manifest from GitHub Secrets
        id: render-secret
        run: |
          set -x
          umask 077
          # write the secret file into the workspace so subsequent actions can access it
          tmpdir="$GITHUB_WORKSPACE"
          tmpfile=$(mktemp -p "$tmpdir" ubuntu-postgis-secret.XXXXXX.yml)
          printf '%s\n' \
            "apiVersion: v1" \
            "kind: Secret" \
            "metadata:" \
            "  name: ubuntu-postgis-secret" \
            "type: Opaque" \
            "stringData:" \
            "  POSTGRES_USER: \"postgres\"" \
            "  POSTGRES_PASSWORD: \"${{ secrets.UBUNTU_POSTGRES }}\"" \
            "  POSTGRES_DB: \"postgres\"" \
            > "$tmpfile"
          chmod 600 "$tmpfile"
          echo "secret_file=$tmpfile" >> $GITHUB_OUTPUT
          set +x

      - name: Apply Secret via OpenShift deployer
        uses: bcgov/action-deployer-openshift@d972993c70aba88e4f2fe66a66c4b7149fa9fcad # v4.0.0
        with:
          oc_namespace: ${{ vars.OC_NAMESPACE }}
          oc_server: ${{ vars.OC_SERVER }}
          oc_token: ${{ secrets.OC_TOKEN }}
          file: ${{ steps.render-secret.outputs.secret_file }}
          overwrite: true

      - name: Purge existing deployment and PVC on re-run
        if: ${{ github.run_attempt > 1 }}
        run: |
          echo "Rerun detected (attempt ${{ github.run_attempt }}). Purging Deployment, Service, Secret and PVC to reset data..."
          set +e
          oc delete deployment ubuntu-postgis --ignore-not-found
          oc delete svc ubuntu-postgis-svc --ignore-not-found
          oc delete secret ubuntu-postgis-secret --ignore-not-found
          oc delete pvc ubuntu-postgis-pvc --ignore-not-found
          set -e
          echo "Purge complete."

      - name: Render deployment with built image
        id: render
        run: |
          # Prefer immutable digest if build produced one, fall back to tag
          if [ -n "${{ steps.build.outputs.digest }}" ]; then
            IMAGE="ghcr.io/${{ github.repository }}/ubuntu-postgis@${{ steps.build.outputs.digest }}"
          else
            IMAGE="ghcr.io/${{ github.repository }}/ubuntu-postgis:${{ steps.vars.outputs.tag }}"
          fi
          echo "Using image: $IMAGE"
          # Replace placeholder in the plain Kubernetes manifest
          cp postgres-oracle/ubuntu-postgis-deploy.yml rendered-ubuntu-postgis-deploy.yml
          sed -i "s|IMAGE_PLACEHOLDER|$IMAGE|g" rendered-ubuntu-postgis-deploy.yml
          echo "rendered_file=rendered-ubuntu-postgis-deploy.yml" >> $GITHUB_OUTPUT

      - name: Deploy Ubuntu PostGIS to OpenShift
        id: deploy
        uses: bcgov/action-deployer-openshift@d972993c70aba88e4f2fe66a66c4b7149fa9fcad # v4.0.0
        with:
          oc_namespace: ${{ vars.OC_NAMESPACE }}
          oc_server: ${{ vars.OC_SERVER }}
          oc_token: ${{ secrets.OC_TOKEN }}
          file: ${{ steps.render.outputs.rendered_file }}
          overwrite: true
          timeout: 15m

      - name: Cleanup secret file
        if: always()
        run: |
          set +x
          tmp="${{ steps.render-secret.outputs.secret_file }}"
          if [ -n "$tmp" ] && [ -f "$tmp" ]; then
            shred -u "$tmp" || rm -f "$tmp"
          fi
          set -x
